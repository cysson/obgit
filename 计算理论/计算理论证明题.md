# 计算理论证明题

本文档根据**TJU人工智能数学基础**课程的课堂PPT和个人理解整理而成，如有纰漏，欢迎指正



## 定义



**图灵机**
$$
(Q, \Sigma, \Gamma, \delta ,q_0, q_{accept}, q_{reject})
$$

$$
\delta : Q \times \Gamma \to Q \times \Gamma \times \{L, R\}
$$

**多带图灵机**
$$
\delta : Q \times \Gamma^k \to Q \times \Gamma^k \times \{L, R, S\}^k
$$

**非确定型图灵机**
$$
\delta : Q \times \Gamma \to P(Q \times \Gamma \times \{L, R\})
$$

**DFA 接受问题**
$$
A_{DFA} = \{ <B, w>|\ B是 DFA 并且接受输入串 w\}
$$


**NFA 接受问题（非确定型有穷自动机）**
$$
A_{NFA} = \{ <B, w>|\ B是 NFA 并且接受输入串 w\}
$$

**语言为空**
$$
E_{DFA} = \{ <A>|\ A 是 DFA 且 L(A) = \varnothing\}
$$

**识别同一个语言**
$$
EQ_{DFA} = \{ <A, B>|\ A 和 B 都是 DFA 且 L(A) = L(B)\}
$$

**Ld**
$$
L_d = \{ w_i | w_i \in \{ 0, 1\}^*, w_i \notin L(M_i) \}
$$

**Lu**
$$
L_u = \{ <M, w> | w \in \{ 0, 1\}^*, M 是一个图灵机且接受 w \}
$$

**Lh**
$$
L_h = \{ <M, w> | w \in \{ 0, 1\}^*, M 是一个图灵机且对 w 停机 \}
$$

**归约**
$$
w \in A \Leftrightarrow f(w) \in B
$$

$$
A \le_m B
$$







## 汇总


每个多带图灵机等价于某一个单带图灵机

一个语言是图灵可识别的，当且仅当存在多带图灵机识别它

每个非确定性图灵机都等价于某一个确定型图灵机

一个语言是图灵可识别的，当且仅当存在非确定型图灵机识别它

一个语言是图灵可判定的，当且仅当存在非确定型图灵机判定它

一个语言是图灵可识别的，当且仅当存在枚举器枚举它



如果语言 $L$ 是递归语言，则 $\overline{L}$ 也是递归语言

如果一个语言 $L$ 和它的补 $\overline{L}$ 都是递归可枚举的，则 $L$ 是递归的



$A_{DFA}$ 是一个可判定语言

$A_{NFA}$ 是一个可判定语言

$E_{DFA}$ 是一个可判定语言

$EQ_{DFA}$ 是一个可判定语言



$A_{CFG}$ 是一个可判定语言

$E_{CFG}$ 是一个可判定语言

每一个上下文无关语言都是可判定的



$L_d$ 不是递归可枚举语言，也就是说，不存在识别语言 $L_d$ 的图灵机

$L_u$ 是递归可枚举语言，即通用图灵机 $M_u$ 是存在的

通用语言 $L_u$ 不是递归语言，即 $L_u$ 是不可判定语言

$L_h$ 不是递归语言，即图灵停机问题是不可判定的



如果存在从 $P_1$ 到 $P_2$ 的归约，那么：

​	若  $P_1$ 是不可判定的，则 $P_2$ 也是不可判定的

​	若  $P_1$ 是非递归可枚举的，则 $P_2$ 也是非递归可枚举的





证明 $PATH \in P$	

若 $A \le_P B$ 且 $B\in P$，则 $A \in P$

证明 $3SAT$ 多项式时间可归约到 $CLIQUE$







## 证明


### 图灵可识别



#### 每个多带图灵机等价于某一个单带图灵机

**证明思路：** 

- 使用单带图灵机模拟多带图灵机
- 多带拼在一起，用 $\#$ 分隔
- 拼好后的单带第一段是 $w_1w_2\cdots w_n$，后面每段都是 $\sqcup$



**证明步骤：**

- $S$ 在自己的纸带上写上 $\#w_1w_2\cdots w_n\#\sqcup\#\sqcup\#\cdots \#$ 代表多带图灵机的全部 $k$ 个纸带的内容
- $S$ 的读写头先从纸带最左端 $\#$ 开始向右扫描，直到第 $k+1$ 个，从而确定虚拟头写下的符号，然后进行第二次扫描，模拟多带图灵机的运行
- $S$ 读写头每次运行到 $\#$ 都意味着读到了原纸带的空白区域，$S$ 写下空格，纸带后面的符号整体向右移动一格，继续模拟







#### 一个语言是图灵可识别的，当且仅当存在多带图灵机识别它

**证明思路**

- 单带图灵机自然是多带图灵机，一个语言是图灵可识别的，则存在单带图灵机识别它
- 每个多带图灵机等价于某一个单带图灵机，多带图灵机识别该语言，等价于一个单带图灵机识别，该语言是图灵可是别的









#### 每个非确定性图灵机都等价于某一个确定型图灵机

**证明思路：**

- 用确定型图灵机模拟非确定型图灵机
- 建立三个纸带
  - 第一个纸带存储原输入，作为备份
  - 第二个纸带作为缓存，进行运行的模拟
  - 第三个纸带作为状态寄存器，记录当前分支



**证明步骤：**

- 开始时，第一条纸带包含输入 $w$，第二条纸带和第三条纸带都是空的
- 把第一条纸带的内容复制到第二条纸带上，并把第三条纸带初始化为空字符串
- 用第二条纸带模拟 $N$ 在输入 $w$ 上的非确定计算的某个分支，每一步查询第三条纸带上的下一步
- 如果进入拒绝状态或第三条纸带上没有下一个符号，则拒绝，如果进入接受状态则接受
- 第三条纸带用字典序的下一个串代替原有的串，转到第二步继模拟下一个分支







#### 一个语言是图灵可识别的，当且仅当存在非确定型图灵机识别它

- 确定型图灵机自然是一个非确定型图灵机
- 每个非确定性图灵机都等价于某一个确定型图灵机







#### 一个语言是图灵可判定的，当且仅当存在非确定型图灵机判定它

**证明思路：**

- 在证明每个非确定性图灵机都等价于某一个确定型图灵机的基础上证明
- 如果 $N$ 在计算的所有分支上都能停机，则 $D$ 也总能停机





#### 一个语言是图灵可识别的，当且仅当存在枚举器枚举它

**证明思路：**

- 先证明如果有枚举器 $E$ 枚举语言 $A$，则有图灵机 $M$ 识别 $A$
- 再证明如果图灵机 $M$ 识别语言 $A$，则可为 $A$ 构造枚举器 $E$



**证明步骤：**

- 先证明如果有枚举器 $E$ 枚举语言 $A$，则有图灵机 $M$ 识别 $A$
  - 构造图灵机 $M$，其具有输入 $w$
  - 枚举器 $E$ 运行输出串，将其与 $w$ 比较
  - 如果 $w$ 在其输出的串中出现过，则 $M$ 接受
- 再证明如果图灵机 $M$ 识别语言 $A$，则可为 $A$ 构造枚举器 $E$
  - 对于所有可能的串，输入图灵机 $M$ 运行
  - 如果 $M$ 接受，则 $E$ 打印对应的串









### 图灵可判定



#### 如果语言 $L$ 是递归语言，则 $\overline{L}$ 也是递归语言

**证明思路：**

- 构造一个新图灵机 $\overline{M}$，能够接受 $\overline{L}$ 
- 新的图灵机的接受状态是原图灵机的拒绝状态，新图灵机的拒绝状态是原图灵机的接受状态

**证明步骤：**

- 对于某个总停机的图灵机 $M$，设 $L = L(M)$。 构造一个新的图灵机 $\overline{M}$, 使得 $\overline{L} = L(\overline{M})$
-  $M$ 的接受状态都改成 $\overline{M}$ 的非接受状态
-  $\overline{M}$ 有一个新接受状态 $r$ ，没有从 $r$ 出发的转移
- 将  $M$ 停机不接受的状态都添加一个到接受状态 $r$​ 的转移
- 由于 $M$ 保证停机，则 $\overline{M}$ 也保证停机，而且 $\overline{M}$ 接受 $M$ 不接受的串







#### 如果一个语言 $L$ 和它的补 $\overline{L}$ 都是递归可枚举的，则 $L$​ 是递归的

 **证明思路：**

- 构造两带图灵机，其中一带模拟运行 $L$ 的图灵机 $M$，另一带运行 $\overline{L}$ 的图灵机 $\overline{M}$
- 这个两带图灵机在 $M$ 接受时接受，在 $\overline{M}$接受时拒绝
- 这个图灵机接受的语言与 $L$ 相同，且其对任何输入都停机

**证明步骤：**

- 设 $L = L(M_1)$ 且 $\overline{L} = L(M_2)$。 构造图灵机 $M$ 平行地模拟 $M_1$ 和 $M_2$。 考虑 $M$ 是 2 带图灵机，$M$ 的一条纸带模拟 $M_1$ 的纸带进行工作，$M$ 的另一条纸带模拟 $M_2$ 的纸带进行工作。$M_1$ 和 $M_2$ 的状态分别是 $M$ 的状态的一个分量。
  - 如果 $M$ 的输入 $w$ 属于 $L$，则 $M_1$ 最终将接受，此时 $M$ 接受且停机
  - 如果 $w$ 不属于 $L$，则 $w \in \overline{L}$ ，所以 $M_2$ 最终将接受，当 $M_2$ 接受时，$M$ 停机不接受

- 因此，在所有输入上 $M$ 都停，$L(M)$ 恰好是 $L$，因为 $M$ 总是停机，且 $L(M) = L$，所以 $L$ 是递归的





#### $A_{DFA}$ 是一个可判定语言

检测一个特定的确定型有穷自动机是否接受给定的串

**证明思路：**

- 设计一个判定 $A_{DFA}$​ 的图灵机 $M$，在输入 $w$ 上模拟 $B$
- 如果模拟以接受状态结束则接受，非接受状态则拒绝
- 此模拟器的输入应为 $B111w$ ，若输入不正确也应拒绝

**证明步骤：**

- 只要设计一个判定 $A_{DFA}$ 的图灵机 $M$ 即可。M 对于输入 $<B, w>$ ，其中 $B$ 是 DFA，$w$ 是输入字符串：
  - 在输入 $w$ 上模拟 $B$
  - 如果模拟以接受状态结束，则接受；如果以非接受状态结束，则拒绝

- 输入 $<B, w>$ 的编码为 $B111w$。当 $M$ 收到输入时，首先检查它是否正确地表示了 DFA $B$ 和字符串 $w$，如果不是，则拒绝。然后 $M$ 直接执行模拟






#### $A_{NFA}$ 是一个可判定语言

**证明思路：**

- 思路一：与证明$A_{DFA}$ 是一个可判定语言的方法类似，构造图灵机 $N$ 模拟判定
- 思路二：将 M 作为 N 的子程序，先将 N 的输入转化为 DFA，再输入 M 进行判定

**证明步骤：**

- 用 $M$ 作为 $N$ 的子程序。因为 $M$ 只接收 DFA 作为输入，故先将 $N$ 作为输入所收到的 NFA 转换成 DFA，然后再将它传给 $M$
- N 对于输入$<B, w>$ ，其中 $B$ 是 NFA，$w$ 是输入字符串
  - 将 NFA $B$ 转换成一个等价的 DFA $C$
  - 在输入 $<C, w>$ 上运行图灵机 $M$
  - 如果 M 接受，则接受，否则拒绝









#### $E_{DFA}$ 是一个可判定语言

一个图灵机没有可接受语言是可判定的

**证明思路：**

- 从起点出发，把每个可达的状态都标记
- 所有可达的状态都标记后，如果被标记的状态中没有接受状态，则接受



**证明步骤：**

- DFA 接受一个串当且仅当：从起始状态出发，沿着此 DFA 的箭头方向，能够到达一个接收状态。设计一个使用标记算法的图灵机 $T$。$T$ 对 于输入 $<A>$ 其中 $A$ 是一个 DFA: 
  - 标记 $A$ 的起始状态
  - 重复下列步骤，直到所有状态都被标记
  - 对于一个状态，如果有一个到达它的转移是从某个已经标记过的状态出发的，则将其标记
  - 如果没有接受状态被标记，则接受，否则拒绝










#### $EQ_{DFA}$ 是一个可判定语言

两个图灵机的语言相同是可判定的

**证明思路：**

- 构造一个只接受 $A$ 或 $B$ 接受但不同时接受的串的图灵机 $C$
- 这个图灵机的语言是 $A$ 和 $B$ 语言的对称差
- 如果 $C$ 的语言为空，则 $L(A) = L(B)$



**证明步骤：**

-  $A$ 和 $B$ 来构造一个新的 DFA $C$，使得 C 只接受这样的串：$A$ 或 $B$ 接受但不是都接受。显然，如果 $A$ 和 $B$ 识别相同的语言，则 $C$ 不接受任何串。即 $C$ 的语言是

$$
L(C) = (L(A) \cap \overline{L(B)}) \cup (\overline{L(A)} \cap L(B))
$$

- 检查 $L(C)$ 是否为空，如果它是空的，$L(A)$ 与 $L(B)$ 必定相等。$F$ 对于输入 $<A,B>$ 其中 $A$ 和 $B$ 都是 DFA
  - 如上描述构造 DFA $C$
  - 在输入 $<C>$ 上运行上一定理中的图灵机 $T$
  - 如果 $T$ 接受，则接受；如果 $T$ 拒绝，则拒绝







### 通用语言



#### $L_d$ 不是递归可枚举语言，也就是说，不存在识别语言 $L_d$​ 的图灵机

$$
L_d = \{ w_i | w_i \in \{ 0, 1\}^*, w_i \notin L(M_i) \}
$$

$L_d$ 的图灵机编码和语言是一样的，序号为 $i$ 的图灵机是 $M_i$ ， $M_i$ 的编码和语言都是 $w_i$

**证明思路：**

- 使用反证法，假设存在能识别 $L_d$ 的图灵机 $M$，则考察 $M$ 的编码 $w$ 是不是 $M$ 的语言
- 如果是，则 $w$ 也是 $L_d$ 之一，那么 $w$ 根据 $L_d$ 规则应当不是 $M$ 的语言，矛盾
- 如果不是，则 $w$ 不是 $L_d$ 之一，那么 $w$ 应当能被 $M$ 识别，又矛盾

**证明步骤：**

- 反证法。假设 $L_d$ 是递归可枚举语言，则存在某个图灵机 $M$，使得 $L(M) = L_d$。因为 $L_d$ 是字母表 $\{0, 1\}$ 上的语言，则 $M$ 至少有一个编码 $j$，即 $M = M_j$
- 现在询问 $w_j$ 是否属于 $L(M_j)$
  - 若 $w_j \in L(M_j )$，则 $w_j \in L_d$。由 $L_d$ 定义，可知 $w_j$ 不能被 $L(M_j )$ 接 受，即 $w_j \notin L(M_j )$矛盾
  - 若 $w_j \notin L(M_j )$，则 $w_j \notin L_d$，由 $L_d$ 定义，从而 $w_j \in L(M_j )$ 矛盾

- 因此, 假设存在矛盾，$L_d$ 不是递归可枚举语言







#### $L_u$ 是递归可枚举语言，即通用图灵机 $M_u$​ 是存在的

**证明思路：**

- 三带图灵机
  - 第一带存放编码 $M111w$
  - 第二带模拟 $w$  在 $M$ 上的运算
  - 第三带存放 $M$ 的当前状态 $q_i$

**证明步骤：**

- 设计 $M_u$ 为一个 3 带图灵机，其中
  - 第 1 带存放 $<M,w>$ 的编码，即 $M111w$
  - 第 2 带用于 $M_u$ 模拟 $M$ 在 $w$ 上的运算
  - 第 3 带始终存放 $M$ 的当前状态 $q_i$ ( $0^i$ )
  
- $M_u$ 的工作方式如下： 

  - $M_u$ 检查输入是否正确

  - 初始化：把第 1 带上的 $w$ 抄写到第 2 带上，读写头指向 $w$ 的第 1 个符号，在第 3 带上打印 0，代表初始状态 $q_1$

  - $M_u$ 模拟 $M$ 的每一个动作，若当前 $M$ 处于状态 $q_i$ (第 3 带上为 $0^i$ )，第 2 带读写头读入的符号为 $x_j$，若有定义 $(q_i, x_j )=(q_k, x_l, D_m)$ 则 $M_u$ 在第 1 带上找其编码 $0^i10^j10^k10^l10^m$ ，然后执行：

    - 抹去第 3 带上的 $0^i$ 并打印 $0^k$ ，代表状态 $q_k$

    - 第 2 带读写头注视的方格上打印 $0^l$ ，代表符号 $x_l$

    - 第 2 带读写头根据 $m = 1$ 或 $m = 2$， 执行向左移动或者向右移动

  - 如果无定义（第二带上找不到编码）则 $M_u$ 停机






#### 通用语言 $L_u$ 不是递归语言，即 $L_u$ 是不可判定语言

**证明思路：**

- 根据性质：“如果语言 $L$ 是递归语言，则 $\overline{L}$ 也是递归语言”，证明 $\overline{L}$ 不是递归语言即可
- 使用反证法，假设 $\overline{L_u}$ 是递归语言，其图灵机是 $M$
- 利用 $M_i,w_i$ ，假设 $L_u$ 的图灵机是 $M_i$  其对应编码 $w_i$
- 使用另一个图灵机 $M'$ ，将输入转换为 $w111w$ 并模拟 $M$​
- $w_i$ 作为 $M_i$ 的编码，如果 $M$ 接受 $w$ 当且仅当 $M_i$ 不接受，触发了 $L_d$​
- $w_i \in L_d$ ，与 $L_d$ 是非递归可枚举语言矛盾







#### $L_h$​ 不是递归语言，即图灵停机问题是不可判定的

**证明思路：**

- 使用反证法，假设 $\overline{L_h}$ 是递归语言，其图灵机是 $M$
- 证明同上







### 归约

如果存在从 $P_1$ 到 $P_2$ 的归约，那么：

​	若  $P_1$ 是不可判定的，则 $P_2$ 也是不可判定的

​	若  $P_1$ 是非递归可枚举的，则 $P_2$ 也是非递归可枚举的

**证明思路：**

- 对于判定：将 $P_1$ 归约到 $P_2$ ，再对 $P_2$ 判定
- 对于非递归可枚举：假设$P_1$ 是非递归可枚举的, 而 $P_2$ 是递归可枚举，构造图灵机，产生矛盾




**证明步骤：**

- 若可以判定 $P_2$，则可以把从 $P_1$ 到 $P_2$ 的归约与判定 $P_2$ 的算法组合起来，构造一个判定 $P_1$ 的算法。具体地说，给定 $P_1$ 的一个实例 $x$，对 $x$ 使用归约算法，这个算法将 $x$ 转化成 $P_2$ 的一个实例 $y$。对 $y$ 使用判定 $P_2$ 的算法

  - 若算法结果为“是”，因为 $P_1$ 可归约到 $P_2$，所以 $P_1$ 对于 $w$ 回答为是
  - 若算法结果为“否”，因为 $P_1$ 可归约到 $P_2$，所以 $P_1$ 对于 $w$​ 回答为否



- 假设 $P_1$ 是非递归可枚举的，而 $P_2$ 是递归可枚举的，则存在一台图灵机识别 $P_2$。从 $P_1$ 的一个实例 $x$ 开始，将其归约为 $P_2$ 的一个实例 $y$
  - 如果 $x$ 属于 $P_1$，则 $y$ 属于 $P_2$，所以图灵机接受 $x$
  - 如果 $x$ 不属于 $P_1$，则 $y$ 不属于 $P_2$，所以图灵机将不接受 $x$
- 这就构造出一台识别 $P_1$ 的图灵机，这与 $P_1$ 是非递归可枚举矛盾





### P / NP

#### 证明 $PATH \in P$​	

**证明思路：**

- 对起点和所有有路径可达的节点标记
- 若目标被标记则接受，否则拒绝





#### 若 $A \le_P B$ 且 $B\in P$，则 $A \in P$​

设 $M$ 是判定 $B$ 的多项式时间算法，$f$ 是从 $A$ 到 $B$ 的多项式时间归约

- $N$ 对输入 $w$: 
  - 计算 $f(w)$
  - 在输入 $f(w)$ 上运行 $M$，输出 $M$ 的输出
- 若 $w \in A$, 则 $f(w) \in B$, 因为 $f$ 是从 $A$ 到 $B$ 的归约。于是, 只要 $w \in  A$，$M$ 就接受 $f(w)$。 另外，因为 $N$ 的两个步骤都在多项式时间内运行，故 $N$ 在多项式时间内运行.

