##  伪代码
### 活动安排

### 最大子序列和（kadane）
```cpp
#include <vector>
using namespace std;

int MaxSubarraySum(const vector<int>& x) {
    if (x.empty()) return 0;
    int global_max = x[0];
    int current_max = x[0];
    for (size_t i = 1; i < x.size(); ++i) {
        current_max = max(x[i], current_max + x[i]);
        if (current_max > global_max) {
            global_max = current_max;
        }
    }
    return global_max;
}
```

### 最大子序列和（分治）
求最优值 f(i,j) 中的 i 和 j
```cpp
#include <vector>
using namespace std;

tuple<int, int, int> MaxSubarraySumWithIndices(const vector<int>& x) {
    if (x.empty()) return {0, 0, 0};
    int global_max = x[0];
    int current_max = x[0];
    int global_start = 0, global_end = 0;
    int current_start = 0, current_end = 0;
    for (size_t i = 1; i < x.size(); ++i) {
        if (current_max + x[i] > x[i]) {
            current_max += x[i];
            current_end = i;
        } else {
            current_max = x[i];
            current_start = i;
            current_end = i;
        }
        if (current_max > global_max) {
            global_max = current_max;
            global_start = current_start;
            global_end = current_end;
        }
    }
    return {global_max, global_start, global_end};
}
```
